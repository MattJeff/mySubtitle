import { YouTubeSubtitleOverlay, type SubtitleStyle } from './overlay';
import { SubtitleSyncEngine } from '../utils/sync-engine';
import { SRTParser } from '../utils/srt-parser';
import { YouTubeCaptionExtractor } from '../utils/youtube-captions';

console.log('SubStyle: Content script loaded');

class SubStyleManager {
    private overlay: YouTubeSubtitleOverlay;
    private syncEngine: SubtitleSyncEngine | null = null;
    private video: HTMLVideoElement | null = null;
    private lastDisplayedText: string = '';
    private currentStyle: SubtitleStyle = {
        fontFamily: 'Montserrat',
        fontSize: 48,
        color: '#FFFFFF',
        outlineWidth: 2,
        outlineColor: '#000000',
        animation: 'pop'
    };

    constructor() {
        this.overlay = new YouTubeSubtitleOverlay();
        this.init();
        this.detectUrlChange();
    }

    private async init() {
        this.findVideo();
        await this.loadSubtitles();
        this.setupMessageListener();
    }

    private detectUrlChange() {
        // Detect URL changes (YouTube is SPA)
        let lastUrl = window.location.href;

        setInterval(() => {
            const currentUrl = window.location.href;
            if (currentUrl !== lastUrl) {
                console.log('SubStyle: URL changed, clearing subtitles');
                // Clear subtitles
                this.syncEngine = new SubtitleSyncEngine([]);
                this.lastDisplayedText = '';
                this.overlay.updateText('', this.currentStyle);

                // Notify extension about URL change to cancel any ongoing processing
                chrome.storage.local.get(['isProcessing', 'processingUrl'], (result) => {
                    if (result.isProcessing && result.processingUrl && result.processingUrl !== currentUrl) {
                        console.log('SubStyle: Clearing processing state due to URL change');
                        chrome.storage.local.remove(['isProcessing', 'processingUrl']);
                    }
                });

                // Reinitialize for new video
                this.findVideo();

                lastUrl = currentUrl;
            }
        }, 1000);
    }

    private findVideo() {
        const video = document.querySelector('video');
        if (video) {
            this.video = video;
            this.setupVideoListeners();
            console.log('SubStyle: Video found');
        } else {
            setTimeout(() => this.findVideo(), 1000);
        }
    }

    private setupVideoListeners() {
        if (!this.video) return;

        this.video.addEventListener('timeupdate', () => {
            if (this.syncEngine && this.video) {
                const currentTimeMs = this.video.currentTime * 1000;
                const cue = this.syncEngine.getCurrentCue(currentTimeMs);

                const newText = cue ? cue.text : '';

                // Only update if text has changed
                if (newText !== this.lastDisplayedText) {
                    console.log(`SubStyle: Found cue at ${currentTimeMs}ms:`, newText);
                    this.overlay.updateText(newText, this.currentStyle);
                    this.lastDisplayedText = newText;
                }
            }
        });

        // Hide native subtitles when video plays
        this.video.addEventListener('play', () => {
            console.log('SubStyle: Video playing, hiding native subtitles');
            this.overlay.hideNativeSubtitles();
        });
    }

    private async loadSubtitles() {
        try {
            // Try to extract YouTube captions
            const captionTracks = await YouTubeCaptionExtractor.extractCaptionTracks();

            if (captionTracks.length > 0) {
                console.log('SubStyle: Found caption tracks:', captionTracks);

                // Prefer non-auto-generated captions
                const preferredTrack = captionTracks.find(t => !t.isAutoGenerated) || captionTracks[0];
                console.log('SubStyle: Using track:', preferredTrack.name);

                // Fetch caption content
                const srtContent = await YouTubeCaptionExtractor.fetchCaptions(preferredTrack.baseUrl);
                const cues = SRTParser.parse(srtContent);

                this.syncEngine = new SubtitleSyncEngine(cues);
                console.log(`SubStyle: Loaded ${cues.length} captions from YouTube`);
            } else {
                console.warn('SubStyle: No YouTube captions found, video may not have subtitles');
                this.syncEngine = new SubtitleSyncEngine([]);
            }
        } catch (error) {
            console.error('SubStyle: Error loading YouTube captions:', error);
            // No fallback - just use empty subtitles
            this.syncEngine = new SubtitleSyncEngine([]);
        }
    }

    private setupMessageListener() {
        chrome.runtime.onMessage.addListener((message: any, _sender: chrome.runtime.MessageSender, sendResponse: (response?: any) => void) => {
            // Handle different message types
            if (message.type === 'UPDATE_STYLE') {
                this.currentStyle = message.style;
                console.log('SubStyle: Style updated', this.currentStyle);
                return false;
            } else if (message.type === 'GET_VIDEO_INFO') {
                // Return video info to popup
                const title = document.querySelector('h1.ytd-watch-metadata yt-formatted-string')?.textContent || 'Unknown Video';
                const duration = this.video?.duration || 0;
                const currentTime = this.video?.currentTime || 0;

                sendResponse({
                    title,
                    duration: this.formatTime(duration),
                    currentTime: this.formatTime(currentTime),
                    hasVideo: !!this.video
                });
                return false;
            } else if (message.type === 'LOAD_SUBTITLES') {
                // Load subtitles from backend-generated SRT
                console.log('SubStyle: Loading subtitles from backend');
                const cues = SRTParser.parse(message.srt_content);
                this.syncEngine = new SubtitleSyncEngine(cues);
                console.log(`SubStyle: Loaded ${cues.length} subtitles from backend`);
                return false;
            } else if (message.type === 'LOAD_YOUTUBE_TRANSCRIPT') {
                // Load subtitles from YouTube native transcript
                console.log('SubStyle: Loading YouTube transcript');
                this.syncEngine = new SubtitleSyncEngine(message.cues);
                console.log(`SubStyle: Loaded ${message.cues.length} subtitles from YouTube transcript`);
                return false;
            } else if (message.type === 'CHECK_TRANSCRIPT_AVAILABLE' || message.type === 'EXTRACT_YOUTUBE_TRANSCRIPT') {
                // Handle async operations that need import
                (async () => {
                    try {
                        console.log(`SubStyle: Handling message type: ${message.type}`);
                        const { YouTubeTranscriptExtractor } = await import('../utils/youtube-transcript-extractor');

                        if (message.type === 'CHECK_TRANSCRIPT_AVAILABLE') {
                            const available = YouTubeTranscriptExtractor.hasTranscriptAvailable();
                            console.log(`SubStyle: Transcript availability check: ${available}`);
                            sendResponse({ available });
                        } else if (message.type === 'EXTRACT_YOUTUBE_TRANSCRIPT') {
                            console.log('SubStyle: Starting transcript extraction...');
                            const cues = await YouTubeTranscriptExtractor.extractTranscript();

                            if (!cues) {
                                console.error('SubStyle: extractTranscript returned null');
                                sendResponse({ error: 'No transcript available for this video' });
                            } else if (cues.length === 0) {
                                console.error('SubStyle: extractTranscript returned empty array');
                                sendResponse({ error: 'Transcript found but no segments extracted' });
                            } else {
                                console.log(`SubStyle: Successfully extracted ${cues.length} cues`);
                                sendResponse({ cues });
                            }
                        }
                    } catch (error) {
                        console.error('SubStyle: Error in async message handler:', error);
                        const errorMessage = error instanceof Error ? error.message : String(error);
                        sendResponse({ error: errorMessage });
                    }
                })();
                return true; // Keep channel open for async response
            }

            return false;
        });
    }

    private formatTime(seconds: number): string {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
}

// Start the manager
new SubStyleManager();
