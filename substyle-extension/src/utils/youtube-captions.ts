/**
 * YouTube Caption Extractor
 * Extracts caption URLs from YouTube's player response
 */

export interface CaptionTrack {
    baseUrl: string;
    languageCode: string;
    name: string;
    isAutoGenerated?: boolean;
}

export class YouTubeCaptionExtractor {
    /**
     * Extract ytInitialPlayerResponse from script tags in the page
     */
    private static parseFromScriptTags(): any {
        const scripts = document.querySelectorAll('script');

        for (const script of scripts) {
            const content = script.textContent || '';

            // Look for ytInitialPlayerResponse in script content
            const match = content.match(/var ytInitialPlayerResponse = ({.+?});/);
            if (match && match[1]) {
                try {
                    return JSON.parse(match[1]);
                } catch (e) {
                    console.warn('SubStyle: Failed to parse ytInitialPlayerResponse from script tag');
                }
            }
        }

        return null;
    }

    /**
     * Extract caption tracks from ytInitialPlayerResponse
     */
    static async extractCaptionTracks(): Promise<CaptionTrack[]> {
        try {
            // First try window object
            let playerResponse = (window as any).ytInitialPlayerResponse;

            // If not found, parse from script tags
            if (!playerResponse) {
                playerResponse = this.parseFromScriptTags();
            }

            if (!playerResponse) {
                console.warn('SubStyle: ytInitialPlayerResponse not found in window or script tags');
                return [];
            }

            const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

            if (!captionTracks || !Array.isArray(captionTracks)) {
                console.warn('SubStyle: No caption tracks found in player response');
                return [];
            }

            console.log('SubStyle: Found', captionTracks.length, 'caption tracks');
            return captionTracks.map((track: any) => ({
                baseUrl: track.baseUrl,
                languageCode: track.languageCode,
                name: track.name?.simpleText || track.languageCode,
                isAutoGenerated: track.kind === 'asr'
            }));
        } catch (error) {
            console.error('SubStyle: Error extracting caption tracks:', error);
            return [];
        }
    }

    /**
     * Fetch caption content from YouTube
     */
    static async fetchCaptions(baseUrl: string): Promise<string> {
        try {
            // Add format parameter to get SRT-like format
            const url = `${baseUrl}&fmt=srv3`;
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`Failed to fetch captions: ${response.statusText}`);
            }

            const xmlText = await response.text();
            return this.parseYouTubeCaptions(xmlText);
        } catch (error) {
            console.error('SubStyle: Error fetching captions:', error);
            throw error;
        }
    }

    /**
     * Parse YouTube's srv3 XML format to SRT format
     */
    private static parseYouTubeCaptions(xmlText: string): string {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
        const textElements = xmlDoc.querySelectorAll('text');

        let srtContent = '';
        let index = 1;

        textElements.forEach((element) => {
            const start = parseFloat(element.getAttribute('start') || '0');
            const duration = parseFloat(element.getAttribute('dur') || '0');
            const end = start + duration;
            const text = element.textContent || '';

            // Convert to SRT format
            srtContent += `${index}\n`;
            srtContent += `${this.formatTime(start)} --> ${this.formatTime(end)}\n`;
            srtContent += `${this.decodeHtmlEntities(text)}\n\n`;
            index++;
        });

        return srtContent;
    }

    /**
     * Format time in SRT format (HH:MM:SS,mmm)
     */
    private static formatTime(seconds: number): string {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        const milliseconds = Math.floor((seconds % 1) * 1000);

        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${milliseconds.toString().padStart(3, '0')}`;
    }

    /**
     * Decode HTML entities in caption text
     */
    private static decodeHtmlEntities(text: string): string {
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }
}
